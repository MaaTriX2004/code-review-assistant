# Technical Discussion: Code Review Assistant

This document details the technical choices, architecture, and potential future improvements for the Code Review Assistant project.

## 1. Technology Choices Rationale

The tech stack was chosen to be modern, efficient, and developer-friendly.

-   **Backend (FastAPI)**: FastAPI was selected over other Python frameworks like Flask or Django because of its high performance, automatic generation of interactive API documentation (via Swagger UI), and its modern use of Python type hints for data validation with Pydantic. This makes API development and testing extremely fast.

-   **Frontend (React + Vite)**: React is the industry standard for building dynamic, component-based user interfaces. Vite was chosen as the build tool over Create React App because of its significantly faster development server startup and Hot Module Replacement (HMR), leading to a much better developer experience.

-   **Styling (Tailwind CSS)**: Tailwind CSS was chosen for its utility-first approach. This allows for building a custom, modern design directly within the HTML/JSX without writing separate CSS files, which speeds up development and makes components more self-contained. The `@tailwindcss/typography` plugin was essential for easily styling the Markdown output.

-   **Database (SQLite)**: For a project of this scale, a full-fledged database like PostgreSQL or MySQL would be overkill. SQLite is a perfect choice because it's serverless, requires zero configuration, and stores the entire database in a single file within the project, making setup and deployment incredibly simple.

## 2. Application Architecture

The application follows a standard **client-server architecture**.

-   The **React frontend** acts as the client. It is responsible for all user interactions and rendering the UI. It is a "dumb" client in that it holds very little business logic and primarily makes API calls to the backend to fetch or modify data.
-   The **FastAPI backend** acts as the server. It contains all the business logic: handling file storage, communicating with the external Gemini API, and managing the database. It exposes a clear RESTful API for the client to consume.

This separation of concerns makes the application easier to develop, debug, and scale. For example, the frontend could be completely replaced with a mobile app without changing the backend at all.

## 3. State Management (Frontend)

The React application employs a **centralized state management** pattern. The main `App.jsx` component is the "single source of truth." It holds all major application states (the list of reviews, the currently active review, loading status, etc.) and passes them down to child components as props. This unidirectional data flow makes the app's behavior predictable and easier to debug, preventing the crashes seen in earlier development stages.

## 4. Future Improvements

While the current application is fully functional, several features could be added to enhance it:

-   **User Authentication**: Implement a login system so that users can have their own private review histories.
-   **Support for Multiple Files/Folders**: Allow users to upload an entire project folder (as a .zip) for a more comprehensive review.
-   **Real-time Updates with WebSockets**: Use WebSockets to stream the review back to the user token-by-token as it's being generated by the LLM, similar to how ChatGPT types out its response.
-   **Different Output Formats**: Allow users to download the review report as a PDF or Markdown file.
-   **More Robust Error Handling**: Display more user-friendly "toast" notifications for errors instead of using `alert()` or an Error Boundary fallback.